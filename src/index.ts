import Joi, { AnySchema } from 'joi';
import Path from 'path';
import fs from 'fs';

import { Describe, parseSchema, getAllCustomTypes, typeContentToTs } from './parse';
import { Settings, ConvertedType } from './types';

export { Settings };

export const defaultSettings = (settings: Partial<Settings>): Settings => {
  const appSettings = { ...settings } as Settings;

  if (appSettings.defaultToRequired === undefined) {
    appSettings.defaultToRequired = false;
  }
  if (!appSettings.schemaFileSuffix) {
    appSettings.schemaFileSuffix = 'Schema';
  }
  if (appSettings.debug === undefined) {
    appSettings.debug = false;
  }
  if (!appSettings.schemaFileSuffix) {
    appSettings.schemaFileSuffix = 'Schema';
  }
  if (!appSettings.fileHeader) {
    appSettings.fileHeader = `/**
 * This file was automatically generated by joi-to-typescript
 * Do not modify this file manually
 */`;
  }
  if (appSettings.sortPropertiesByName === undefined) {
    appSettings.sortPropertiesByName = true;
  }
  return appSettings;
};

export const convertSchema = (settings: Settings, joi: AnySchema): ConvertedType | undefined => {
  const details = joi.describe() as Describe;
  const name = details?.flags?.label;
  if (!name) {
    throw 'At least one "object" does not have a .label()';
  }

  const parsedSchema = parseSchema(details, settings, false);
  if (parsedSchema) {
    const customTypes = getAllCustomTypes(parsedSchema);
    const content = typeContentToTs(parsedSchema, true);
    return {
      name,
      customTypes,
      content
    };
  }

  return undefined;
};

const getTypeFileNameFromSchema = (schemaFileName: string, settings: Settings): string => {
  return schemaFileName.endsWith(`${settings.schemaFileSuffix}.ts`)
    ? schemaFileName.substring(0, schemaFileName.length - `${settings.schemaFileSuffix}.ts`.length)
    : schemaFileName.replace('.ts', '');
};

/**
 * Write type file
 * @param settings Settings
 * @param schemaFileName Schema File Name
 */
export const writeTypeFile = async (settings: Settings, schemaFileName: string): Promise<undefined | string> => {
  const allConvertedTypes: ConvertedType[] = [];

  const fullFilePath = Path.join(settings.schemaDirectory, schemaFileName);
  const schemaFile = await require(fullFilePath);

  for (const iterator in schemaFile) {
    const joiSchema = schemaFile[iterator];

    if (!Joi.isSchema(joiSchema)) {
      continue;
    }
    const convertedType = convertSchema(settings, joiSchema);
    if (convertedType) {
      allConvertedTypes.push(convertedType);
    }
  }

  if (allConvertedTypes.length === 0) {
    if (settings.debug) {
      console.log(`${schemaFile} - Skipped - no Joi Schemas found`);
    }
    return;
  }

  if (settings.debug) {
    console.log(`${schemaFileName} - Processing`);
  }

  // Create Type File Name
  const typeFileName = getTypeFileNameFromSchema(schemaFileName, settings);

  // Clean up type list
  // Sort Types
  const typesToBeWritten = allConvertedTypes.sort(
    (interface1, interface2) => 0 - (interface1.name > interface2.name ? -1 : 1)
  );

  // Write types
  const typeContent = typesToBeWritten.map(typeToBeWritten => typeToBeWritten.content);

  // Get imports for the current file
  const externalTypes: string[] = [];
  const allExternalTypes: string[] = [];
  const allCurrentFileTypeNames = typesToBeWritten.map(typeToBeWritten => typeToBeWritten.name);

  for (const typeToBeWritten of typesToBeWritten) {
    for (const customType of typeToBeWritten.customTypes) {
      if (!allCurrentFileTypeNames.includes(customType)) {
        allExternalTypes.push(customType);
      }
    }
  }
  externalTypes.push(...new Set(allExternalTypes));
  const typeImports: string = externalTypes.length == 0 ? '' : `import { ${externalTypes.join(',\n')} } from '.';\n\n`;

  const fileContent = `${settings.fileHeader}\n\n${typeImports}${typeContent.join('\n\n').concat('\n')}`;

  fs.writeFileSync(Path.join(settings.typeOutputDirectory, `${typeFileName}.ts`), fileContent);

  return typeFileName;
};

/**
 * Write index.ts file
 * @param settings Settings Object
 * @param fileNamesToExport list of file names that will be added to the index.ts file
 */
export const writeIndexFile = (settings: Settings, fileNamesToExport: string[]): void => {
  const exportLines = fileNamesToExport.map(fileName => `export * from './${fileName}';`);
  const fileContent = `${settings.fileHeader}\n\n${exportLines.join('\n').concat('\n')}`;
  fs.writeFileSync(Path.join(settings.typeOutputDirectory, 'index.ts'), fileContent);
};

/**
 * Create types from schemas from a directory
 * @param settings Settings
 */
const convertFilesInDirectory = async (appSettings: Settings, ogTypeOutputDir: string): Promise<string[]> => {
  // Check and resolve directories
  appSettings.schemaDirectory = Path.resolve(appSettings.schemaDirectory);
  if (!fs.existsSync(appSettings.schemaDirectory)) {
    throw `schemaDirectory "${appSettings.schemaDirectory}" does not exist`;
  }
  appSettings.typeOutputDirectory = Path.resolve(appSettings.typeOutputDirectory);
  if (!fs.existsSync(appSettings.typeOutputDirectory)) {
    fs.mkdirSync(appSettings.typeOutputDirectory);
    if (!fs.existsSync(appSettings.typeOutputDirectory)) {
      throw `typeOutputDirectory "${appSettings.typeOutputDirectory}" does not exist`;
    }
  }

  let fileNamesToExport: string[] = [];

  // Load files and get all types
  const files = fs.readdirSync(appSettings.schemaDirectory);
  for (const schemaFileName of files) {
    const subDirectoryPath = Path.join(appSettings.schemaDirectory, schemaFileName);
    if (!appSettings.rootDirectoyOnly && fs.lstatSync(subDirectoryPath).isDirectory()) {
      const typeOutputDirectory = appSettings.flattenTree
        ? appSettings.typeOutputDirectory
        : Path.join(appSettings.typeOutputDirectory, schemaFileName);

      const thisDirsFileNamesToExport = await convertFilesInDirectory(
        {
          ...appSettings,
          schemaDirectory: subDirectoryPath,
          typeOutputDirectory
        },
        ogTypeOutputDir
      );

      if (appSettings.indexAllToRoot || appSettings.flattenTree) {
        fileNamesToExport = fileNamesToExport.concat(thisDirsFileNamesToExport);
      }
    } else {
      const typeFileName = await writeTypeFile(appSettings, schemaFileName);
      if (typeFileName) {
        let dirTypeFileName = typeFileName;
        if (appSettings.indexAllToRoot) {
          const findIndexEnd =
            Path.resolve(appSettings.typeOutputDirectory).indexOf(ogTypeOutputDir) + ogTypeOutputDir.length + 1;
          dirTypeFileName = Path.join(
            appSettings.typeOutputDirectory.substring(findIndexEnd),
            getTypeFileNameFromSchema(schemaFileName, appSettings)
          );
        }
        fileNamesToExport.push(dirTypeFileName);
      }
    }
  }

  if (!appSettings.indexAllToRoot && !appSettings.flattenTree) {
    // Write index.ts
    writeIndexFile(appSettings, fileNamesToExport);
  }

  return fileNamesToExport;
};

/**
 * Create types from schemas from a directory
 * @param settings Settings
 */
export const convertFromDirectory = async (settings: Partial<Settings>): Promise<boolean> => {
  const appSettings = defaultSettings(settings);
  const fileNamesToExport = await convertFilesInDirectory(appSettings, Path.resolve(appSettings.typeOutputDirectory));

  if (appSettings.indexAllToRoot || appSettings.flattenTree) {
    // Write index.ts
    writeIndexFile(appSettings, fileNamesToExport);
  }

  return true;
};

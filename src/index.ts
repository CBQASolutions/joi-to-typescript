import Joi, { ObjectSchema, AnySchema, ArraySchema } from 'joi';
import Path from 'path';
import fs from 'fs';

import {
  getLabel,
  getDescription,
  getRequired,
  getProperties,
  getPropertyName,
  getPropertyType,
  getArrayTypeName
} from 'joiHelpers';
import { PropertiesAndInterfaces, Settings, InterfaceRecord, Property } from 'types';

export { Settings };

const defaultSettings = (settings: Settings): void => {
  if (!settings.defaultToRequired) {
    settings.defaultToRequired = false;
  }
  if (!settings.schemaFileSuffix) {
    settings.schemaFileSuffix = 'Schema';
  }
  if (!settings.debug) {
    settings.debug = false;
  }
  if (!settings.schemaFileSuffix) {
    settings.schemaFileSuffix = 'Schema';
  }
  if (!settings.fileHeader) {
    settings.fileHeader = `/**
 * This file was auto generated by joi-ts-types
 * Do not modify this file manually
 */`;
  }
};

/**
 * Is the type a TypeScript type or Custom
 * @param type type name
 */
export const isTypeCustom = (type: string): boolean => {
  switch (type.replace('[]', '')) {
    case 'string':
    case 'boolean':
    case 'number':
    case 'Date':
      return false;
    default:
      return true;
  }
};

/**
 * Get Interface jsDoc
 */
export const getInterfaceJsDoc = (joi: AnySchema): string => {
  const name = getLabel(joi);
  const description = getDescription(joi);

  if (description) {
    return `/**
 * ${name}
 * ${description}
 */`;
  } else {
    return `/**
 * ${name}
 */`;
  }
};

export const getPropertiesAndInterfaces = (joi: ObjectSchema, defaults: Settings): PropertiesAndInterfaces => {
  const result: PropertiesAndInterfaces = { properties: [], interfaces: [] };

  const joiProperties = getProperties(joi);
  for (const joiProperty of joiProperties) {
    const name = getPropertyName(joiProperty);
    if (!name) {
      if (defaults.debug) {
        console.log('Property Name not found');
      }
      continue;
    }
    const type = getPropertyType(joiProperty);
    if (!type) {
      if (defaults.debug) {
        console.log('Property Type not found');
      }
      continue;
    }

    const required = getRequired(joiProperty) ?? defaults.defaultToRequired;

    const content = `  /**
   * ${name}
   */
  ${name}${required ? '' : '?'}: ${type};`;
    const property: Property = {
      name,
      type,
      content,
      customType: isTypeCustom(type) ? type.replace('[]', '') : undefined
    };
    result.properties.push(property);
  }

  return result;
};

export const convertSchema = (settings: Settings, joi: AnySchema): InterfaceRecord[] => {
  const types: InterfaceRecord[] = [];

  const name = getLabel(joi);
  if (!name) {
    throw 'At least one "object" does not have a .label()';
  }

  if (joi.type === 'array') {
    const arrayTypeName = getArrayTypeName(joi as ArraySchema);
    if (!arrayTypeName) {
      throw `Array items do not have a .label() for '${name}'`;
    }
    const isCustom = isTypeCustom(arrayTypeName);

    const customTypes: string[] = isCustom ? [arrayTypeName] : [];

    types.push({
      name,
      customTypes,
      content: `${getInterfaceJsDoc(joi)}
export type ${name} = ${arrayTypeName}[];`
    });
  }

  if (joi.type === 'object') {
    const propertiesAndInterfaces = getPropertiesAndInterfaces(joi as ObjectSchema, settings);

    // get all the custom types on properties
    const customTypes: string[] = propertiesAndInterfaces.properties
      .filter(property => property.customType)
      .map(property => property.customType) as string[];

    types.push({
      name,
      customTypes,
      content: `${getInterfaceJsDoc(joi as ObjectSchema)}
export interface ${name} {
${propertiesAndInterfaces.properties.map(p => p.content).join(`\n`)}
}`
    });
  }

  return types;
};

/**
 * Write interface file
 * @param settings Settings
 * @param schemaFileName Schema File Name
 */
export const writeInterfaceFile = async (settings: Settings, schemaFileName: string): Promise<undefined | string> => {
  const allInterfaceRecords: InterfaceRecord[] = [];
  const schemaFile = await require(Path.join(settings.schemaDirectory, schemaFileName));

  for (const iterator in schemaFile) {
    const joiSchema = schemaFile[iterator];

    if (!Joi.isSchema(joiSchema)) {
      continue;
    }
    const interfaceRecords = convertSchema(settings, joiSchema);
    allInterfaceRecords.push(...interfaceRecords);
    console.log(iterator);
  }

  if (allInterfaceRecords.length === 0) {
    return;
  }

  // Create Type File Name
  const typeFileName = schemaFileName.endsWith(`${settings.schemaFileSuffix}.ts`)
    ? schemaFileName.substring(0, schemaFileName.length - `${settings.schemaFileSuffix}.ts`.length)
    : schemaFileName;

  // Clean up interface records list
  const interfacesToBeWritten: InterfaceRecord[] = [];
  interfacesToBeWritten.push(...allInterfaceRecords);

  // Write interfaces
  const interfaceContent = interfacesToBeWritten.map(interfaceToBeWritten => interfaceToBeWritten.content);

  const externalTypes: string[] = [];
  const allExternalTypes: string[] = [];
  for (const interfaceToBeWritten of interfacesToBeWritten) {
    allExternalTypes.push(...interfaceToBeWritten.customTypes);
  }
  externalTypes.push(...new Set(allExternalTypes));

  const typeImports: string = externalTypes.length == 0 ? '' : `import { ${externalTypes.join(',\n')} } from '.';\n\n`;

  const fileContent = `${settings.fileHeader}\n\n${typeImports}${interfaceContent.join('\n\n').concat('\n')}`;

  fs.writeFileSync(Path.join(settings.interfaceDirectory, `${typeFileName}.ts`), fileContent);

  return typeFileName;
};

/**
 * Write index.ts file
 * @param toDirectory the output directory
 * @param fileNamesToExport list of file names that will be added to the index.ts file
 */
export const writeIndexFile = (settings: Settings, fileNamesToExport: string[]): void => {
  const exportLines = fileNamesToExport.map(fileName => `export * from './${fileName}';`);
  const fileContent = `${settings.fileHeader}\n\n${exportLines.join('\n').concat('\n')}`;
  fs.writeFileSync(Path.join(settings.interfaceDirectory, 'index.ts'), fileContent);
};

/**
 * Create interfaces from schemas from a directory
 * @param settings Settings
 */
export const convertFromDirectory = async (settings: Settings): Promise<boolean> => {
  defaultSettings(settings);

  // Check directories
  if (!fs.existsSync(settings.schemaDirectory)) {
    const resolvedFromDirectory = Path.resolve(settings.schemaDirectory);
    throw `fromDirectory "${resolvedFromDirectory}" does not exist`;
  }
  if (!fs.existsSync(settings.interfaceDirectory)) {
    fs.mkdirSync(settings.interfaceDirectory);
    if (!fs.existsSync(settings.interfaceDirectory)) {
      const resolvedToDirectory = Path.resolve(settings.interfaceDirectory);
      throw `toDirectory "${resolvedToDirectory}" does not exist`;
    }
  }

  const fileNamesToExport: string[] = [];

  // Load files and get all interface records
  const files = fs.readdirSync(settings.schemaDirectory);
  for (const schemaFileName of files) {
    const typeFileName = await writeInterfaceFile(settings, schemaFileName);
    if (typeFileName) {
      fileNamesToExport.push(typeFileName);
    }
  }

  // Write index.ts
  writeIndexFile(settings, fileNamesToExport);

  return true;
};
